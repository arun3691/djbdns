diff -U4 -r -N djbdns-1.05/CHANGES djbdns-1.05-p13/CHANGES
--- djbdns-1.05/CHANGES	Sun Feb 11 23:11:45 2001
+++ djbdns-1.05-p13/CHANGES	Wed Oct  3 21:16:44 2001
@@ -373,4 +373,6 @@
 20010211
 	ui: servers print starting message.
 	internal: some respond() declarations.
 	version: djbdns 1.05.
+20010313
+	patch: to dump and reload the cache
diff -U4 -r -N djbdns-1.05/Makefile djbdns-1.05-p13/Makefile
--- djbdns-1.05/Makefile	Sun Feb 11 23:11:45 2001
+++ djbdns-1.05-p13/Makefile	Sat Oct  6 20:24:30 2001
@@ -3,8 +3,10 @@
 SHELL=/bin/sh
 
 default: it
 
+include Makefile.sig
+
 alloc.a: \
 makelib alloc.o alloc_re.o getln.o getln2.o stralloc_cat.o \
 stralloc_catb.o stralloc_cats.o stralloc_copy.o stralloc_eady.o \
 stralloc_num.o stralloc_opyb.o stralloc_opys.o stralloc_pend.o
@@ -148,15 +150,15 @@
 	./compile byte_zero.c
 
 cache.o: \
 compile cache.c alloc.h byte.h uint32.h exit.h tai.h uint64.h cache.h \
-uint32.h uint64.h
+uint32.h uint64.h env.h error.h open.h openreadclose.h
 	./compile cache.c
 
 cachetest: \
-load cachetest.o cache.o libtai.a buffer.a alloc.a unix.a byte.a
-	./load cachetest cache.o libtai.a buffer.a alloc.a unix.a \
-	byte.a 
+load cachetest.o cache.o libtai.a buffer.a alloc.a unix.a byte.a env.a
+	./load cachetest cache.o libtai.a buffer.a unix.a env.a \
+	alloc.a byte.a dns.a
 
 cachetest.o: \
 compile cachetest.c buffer.h exit.h cache.h uint32.h uint64.h str.h
 	./compile cachetest.c
@@ -227,13 +229,13 @@
 
 dns.a: \
 makelib dns_dfd.o dns_domain.o dns_dtda.o dns_ip.o dns_ipq.o dns_mx.o \
 dns_name.o dns_nd.o dns_packet.o dns_random.o dns_rcip.o dns_rcrw.o \
-dns_resolve.o dns_sortip.o dns_transmit.o dns_txt.o
+dns_resolve.o dns_rotateip.o dns_sortip.o dns_transmit.o dns_txt.o
 	./makelib dns.a dns_dfd.o dns_domain.o dns_dtda.o dns_ip.o \
 	dns_ipq.o dns_mx.o dns_name.o dns_nd.o dns_packet.o \
 	dns_random.o dns_rcip.o dns_rcrw.o dns_resolve.o \
-	dns_sortip.o dns_transmit.o dns_txt.o
+	dns_rotateip.o dns_sortip.o dns_transmit.o dns_txt.o
 
 dns_dfd.o: \
 compile dns_dfd.c error.h alloc.h byte.h dns.h stralloc.h gen_alloc.h \
 iopause.h taia.h tai.h uint64.h taia.h
@@ -300,8 +302,12 @@
 compile dns_resolve.c iopause.h taia.h tai.h uint64.h taia.h byte.h \
 dns.h stralloc.h gen_alloc.h iopause.h taia.h
 	./compile dns_resolve.c
 
+dns_rotateip.o: \
+compile dns_rotateip.c byte.h dns.h stralloc.h gen_alloc.h
+	./compile dns_rotateip.c
+
 dns_sortip.o: \
 compile dns_sortip.c byte.h dns.h stralloc.h gen_alloc.h iopause.h \
 taia.h tai.h uint64.h taia.h
 	./compile dns_sortip.c
@@ -319,12 +325,12 @@
 
 dnscache: \
 load dnscache.o droproot.o okclient.o log.o cache.o query.o \
 response.o dd.o roots.o iopause.o prot.o dns.a env.a alloc.a buffer.a \
-libtai.a unix.a byte.a socket.lib
+libtai.a unix.a byte.a sig.a socket.lib
 	./load dnscache droproot.o okclient.o log.o cache.o \
 	query.o response.o dd.o roots.o iopause.o prot.o dns.a \
-	env.a alloc.a buffer.a libtai.a unix.a byte.a  `cat \
+	env.a alloc.a buffer.a libtai.a unix.a byte.a sig.a  `cat \
 	socket.lib`
 
 dnscache-conf: \
 load dnscache-conf.o generic-conf.o auto_home.o libtai.a buffer.a \
@@ -625,11 +631,11 @@
 iopause.h taia.h tai.h uint64.h taia.h uint16.h parsetype.h
 	./compile parsetype.c
 
 pickdns: \
-load pickdns.o server.o response.o droproot.o qlog.o prot.o dns.a \
+load pickdns.o server.o iopause.o response.o droproot.o qlog.o prot.o dns.a \
 env.a libtai.a cdb.a alloc.a buffer.a unix.a byte.a socket.lib
-	./load pickdns server.o response.o droproot.o qlog.o \
+	./load pickdns server.o iopause.o response.o droproot.o qlog.o \
 	prot.o dns.a env.a libtai.a cdb.a alloc.a buffer.a unix.a \
 	byte.a  `cat socket.lib`
 
 pickdns-conf: \
@@ -703,11 +709,11 @@
 gen_alloc.h iopause.h taia.h tai.h uint64.h taia.h
 	./compile random-ip.c
 
 rbldns: \
-load rbldns.o server.o response.o dd.o droproot.o qlog.o prot.o dns.a \
+load rbldns.o server.o iopause.o response.o dd.o droproot.o qlog.o prot.o dns.a \
 env.a libtai.a cdb.a alloc.a buffer.a unix.a byte.a socket.lib
-	./load rbldns server.o response.o dd.o droproot.o qlog.o \
+	./load rbldns server.o iopause.o response.o dd.o droproot.o qlog.o \
 	prot.o dns.a env.a libtai.a cdb.a alloc.a buffer.a unix.a \
 	byte.a  `cat socket.lib`
 
 rbldns-conf: \
@@ -773,9 +779,9 @@
 server.o: \
 compile server.c byte.h case.h env.h buffer.h strerr.h ip4.h uint16.h \
 ndelay.h socket.h uint16.h droproot.h qlog.h uint16.h response.h \
 uint32.h dns.h stralloc.h gen_alloc.h iopause.h taia.h tai.h uint64.h \
-taia.h
+taia.h iopause.h alloc.h
 	./compile server.c
 
 setup: \
 it install
@@ -978,12 +984,12 @@
 timeoutwrite.h
 	./compile timeoutwrite.c
 
 tinydns: \
-load tinydns.o server.o droproot.o tdlookup.o response.o qlog.o \
+load tinydns.o server.o iopause.o droproot.o tdlookup.o response.o qlog.o \
 prot.o dns.a libtai.a env.a cdb.a alloc.a buffer.a unix.a byte.a \
 socket.lib
-	./load tinydns server.o droproot.o tdlookup.o response.o \
+	./load tinydns server.o iopause.o droproot.o tdlookup.o response.o \
 	qlog.o prot.o dns.a libtai.a env.a cdb.a alloc.a buffer.a \
 	unix.a byte.a  `cat socket.lib`
 
 tinydns-conf: \
@@ -1083,12 +1089,12 @@
 compile utime.c scan.h exit.h
 	./compile utime.c
 
 walldns: \
-load walldns.o server.o response.o droproot.o qlog.o prot.o dd.o \
+load walldns.o server.o iopause.o response.o droproot.o qlog.o prot.o dd.o \
 dns.a env.a cdb.a alloc.a buffer.a unix.a byte.a socket.lib
-	./load walldns server.o response.o droproot.o qlog.o \
-	prot.o dd.o dns.a env.a cdb.a alloc.a buffer.a unix.a \
+	./load walldns server.o iopause.o response.o droproot.o qlog.o \
+	prot.o dd.o dns.a libtai.a env.a cdb.a alloc.a buffer.a unix.a \
 	byte.a  `cat socket.lib`
 
 walldns-conf: \
 load walldns-conf.o generic-conf.o auto_home.o buffer.a unix.a byte.a
diff -U4 -r -N djbdns-1.05/Makefile.sig djbdns-1.05-p13/Makefile.sig
--- djbdns-1.05/Makefile.sig	Thu Jan  1 02:00:00 1970
+++ djbdns-1.05-p13/Makefile.sig	Wed Oct  3 21:16:44 2001
@@ -0,0 +1,27 @@
+sig.o: \
+compile sig.c sig.h
+	./compile sig.c
+
+sig_block.o: \
+compile sig_block.c sig.h hassgprm.h
+	./compile sig_block.c
+
+sig_catch.o: \
+compile sig_catch.c sig.h hassgact.h
+	./compile sig_catch.c
+
+sig_pause.o: \
+compile sig_pause.c sig.h hassgprm.h
+	./compile sig_pause.c
+
+sig.a: \
+makelib sig.o sig_block.o sig_catch.o sig_pause.o
+	./makelib sig.a sig.o sig_block.o sig_catch.o sig_pause.o
+
+hassgact.h: \
+choose compile load trysgact.c hassgact.h1 hassgact.h2
+	./choose cl trysgact hassgact.h1 hassgact.h2 > hassgact.h
+
+hassgprm.h: \
+choose compile load trysgprm.c hassgprm.h1 hassgprm.h2
+	./choose cl trysgprm hassgprm.h1 hassgprm.h2 > hassgprm.h
diff -U4 -r -N djbdns-1.05/README djbdns-1.05-p13/README
--- djbdns-1.05/README	Sun Feb 11 23:11:45 2001
+++ djbdns-1.05-p13/README	Wed Oct  3 21:16:44 2001
@@ -1,4 +1,10 @@
+patchlevel fg1
+20010313
+by Florent Guillaume <florent.guillaume@mail.com>
+patch home page: http://mapage.noos.fr/efgeor/djbdns/index.html
+Uses parts of Felix von Leitner's djb-0.5.2 package: http://www.fefe.de/djb/
+
 djbdns 1.05
 20010211
 Copyright 2001
 D. J. Bernstein
diff -U4 -r -N djbdns-1.05/SYSDEPS djbdns-1.05-p13/SYSDEPS
--- djbdns-1.05/SYSDEPS	Sun Feb 11 23:11:45 2001
+++ djbdns-1.05-p13/SYSDEPS	Wed Oct  3 21:16:44 2001
@@ -6,5 +6,7 @@
 iopause.h
 direntry.h
 hasshsgr.h
 hasdevtcp.h
+hassgact.h
+hassgprm.h
 socket.lib
diff -U4 -r -N djbdns-1.05/TARGETS djbdns-1.05-p13/TARGETS
--- djbdns-1.05/TARGETS	Sun Feb 11 23:11:45 2001
+++ djbdns-1.05-p13/TARGETS	Wed Oct  3 21:16:44 2001
@@ -213,4 +213,11 @@
 instcheck
 it
 setup
 check
+sig.o
+sig.a
+sig_catch.o
+sig_block.o
+hassgact.h
+hassgprm.h
+sig_pause.o
diff -U4 -r -N djbdns-1.05/VERSION djbdns-1.05-p13/VERSION
--- djbdns-1.05/VERSION	Sun Feb 11 23:11:45 2001
+++ djbdns-1.05-p13/VERSION	Wed Oct  3 21:16:44 2001
@@ -1 +1 @@
-djbdns 1.05
+djbdns 1.05-fg1
diff -U4 -r -N djbdns-1.05/auto_home.c djbdns-1.05-p13/auto_home.c
--- djbdns-1.05/auto_home.c	Thu Jan  1 02:00:00 1970
+++ djbdns-1.05-p13/auto_home.c	Wed Oct  3 22:15:33 2001
@@ -0,0 +1,3 @@
+const char auto_home[] = "\
+\057\165\163\162\057\154\157\143\141\154\
+";
diff -U4 -r -N djbdns-1.05/axfr-get.c djbdns-1.05-p13/axfr-get.c
--- djbdns-1.05/axfr-get.c	Sun Feb 11 23:11:45 2001
+++ djbdns-1.05-p13/axfr-get.c	Wed Oct  3 00:58:40 2001
@@ -208,15 +208,43 @@
     if (!dns_domain_todot_cat(&line,d1)) return 0;
     if (!stralloc_cats(&line,".:")) return 0;
     if (!stralloc_catulong0(&line,dist,0)) return 0;
   }
+  else if (byte_equal(data,2,DNS_T_SRV)) {
+    uint16 dist, weight, port;
+    if (!stralloc_copys(&line,"S")) return 0;
+    if (!dns_domain_todot_cat(&line,d1)) return 0;
+    if (!stralloc_cats(&line,"::")) return 0;
+    pos = x_copy(buf,len,pos,data,2);
+    uint16_unpack_big(data,&dist);
+    pos = x_copy(buf,len,pos,data,2);
+    uint16_unpack_big(data,&weight);
+    pos = x_copy(buf,len,pos,data,2);
+    uint16_unpack_big(data,&port);
+    x_getname(buf,len,pos,&d1);
+    if (!dns_domain_todot_cat(&line,d1)) return 0;
+    if (!stralloc_cats(&line,".:")) return 0;
+    if (!stralloc_catulong0(&line,dist,0)) return 0;
+    if (!stralloc_cats(&line,":")) return 0;
+    if (!stralloc_catulong0(&line,weight,0)) return 0;
+    if (!stralloc_cats(&line,":")) return 0;
+    if (!stralloc_catulong0(&line,port,0)) return 0;
+  }
   else if (byte_equal(data,2,DNS_T_A) && (dlen == 4)) {
     char ipstr[IP4_FMT];
     if (!stralloc_copys(&line,"+")) return 0;
     if (!dns_domain_todot_cat(&line,d1)) return 0;
     if (!stralloc_cats(&line,":")) return 0;
     x_copy(buf,len,pos,data,4);
     if (!stralloc_catb(&line,ipstr,ip4_fmt(ipstr,data))) return 0;
+  }
+  else if (byte_equal(data,2,DNS_T_PTR)) {
+    if (!stralloc_copys(&line,"^")) return 0;
+    if (!dns_domain_todot_cat(&line,d1)) return 0;
+    if (!stralloc_cats(&line,":")) return 0;
+    x_getname(buf,len,pos,&d1);
+    if (!dns_domain_todot_cat(&line,d1)) return 0;
+    if (!stralloc_cats(&line,".")) return 0;
   }
   else {
     unsigned char ch;
     unsigned char ch2;
diff -U4 -r -N djbdns-1.05/cache.c djbdns-1.05-p13/cache.c
--- djbdns-1.05/cache.c	Sun Feb 11 23:11:45 2001
+++ djbdns-1.05-p13/cache.c	Sat Oct  6 21:27:29 2001
@@ -1,13 +1,24 @@
+#ifdef DUMPCACHE
+#include <stdio.h>
+#include <unistd.h>
+#include "env.h"
+#include "error.h"
+#include "open.h"
+#include "openreadclose.h"
+#endif
 #include "alloc.h"
 #include "byte.h"
 #include "uint32.h"
 #include "exit.h"
 #include "tai.h"
 #include "cache.h"
+#include "dns.h"
+#include "buffer.h"
 
 uint64 cache_motion = 0;
 
+static char *rrobin;
 static char *x = 0;
 static uint32 size;
 static uint32 hsize;
 static uint32 writer;
@@ -86,8 +97,14 @@
   uint32 nextpos;
   uint32 u;
   unsigned int loop;
   double d;
+  static int trigger=0;
+  
+  if (!trigger) {
+    rrobin = env_get("ROUNDROBIN");
+    trigger++;
+  }
 
   if (!x) return 0;
   if (keylen > MAXKEYLEN) return 0;
 
@@ -110,9 +127,13 @@
 
         u = get4(pos + 8);
         if (u > size - pos - 20 - keylen) cache_impossible();
         *datalen = u;
-
+	if (byte_equal(key,2,DNS_T_A)) {
+	  if (rrobin) {
+            dns_rotateip(x + pos + 20 + keylen,u);
+	  }
+	}
         return x + pos + 20 + keylen;
       }
     }
     nextpos = prevpos ^ get4(pos);
@@ -204,4 +225,98 @@
   unused = size;
 
   return 1;
 }
+
+#ifdef DUMPCACHE
+static int fd;
+
+static int cache_writeline(const char *buf, unsigned int len)
+{
+  int w;
+
+  while (len) {
+    w = write(fd,buf,len);
+    if (w == -1) {
+      if (errno == error_intr) continue;
+      close(fd);
+      return -1;
+    }
+    buf += w;
+    len -= w;
+  }
+  return 0;
+}
+
+int cache_dump(void)
+{
+  static char *fn;
+  static char *fntmp;
+  uint32 pos;
+  unsigned int len;
+
+  fn = env_get("DUMPCACHE");
+  if (!fn) return 999;
+  fntmp = env_get("DUMPCACHETMP");
+  if (!fntmp) return 999;
+  fd = open_trunc(fntmp);
+  if (fd == -1) return -1;
+
+  pos = oldest;
+  while (pos < unused) {
+    len = get4(pos + 4) + get4(pos + 8) + 16;
+    if (cache_writeline(x + pos + 4, len)) return -1;
+    pos += 4 + len;
+  }
+  pos = hsize;
+  while (pos < writer) {
+    len = get4(pos + 4) + get4(pos + 8) + 16;
+    if (cache_writeline(x + pos + 4, len)) return -1;
+    pos += 4 + len;
+  }
+
+  if (fsync(fd) == -1) return -1;
+  if (close(fd) == -1) return -1;
+  if (rename(fntmp,fn) == -1) return -1;
+  return 0;
+}
+
+int cache_slurp(const char *fn)
+{
+  static stralloc buf = {0};
+  char *p;
+  uint32 pos;
+  unsigned int len;
+  uint32 keylen;
+  uint32 datalen;
+  struct tai now;
+  struct tai expire;
+  int nb;
+
+  if (openreadclose(fn,&buf,16384) != 1) goto DIE;
+  tai_now(&now);
+  p = buf.s;
+  pos = 0;
+  len = buf.len;
+  nb = 0;
+  while (pos + 16 <= len) {
+    uint32_unpack(p + pos, &keylen);
+    uint32_unpack(p + pos + 4, &datalen);
+    tai_unpack(p + pos + 8, &expire);
+    pos += 16;
+    if (pos + keylen + datalen > len) break; /* missing data */
+    if (!tai_less(&expire,&now)) {
+      tai_sub(&expire,&expire,&now);
+      cache_set(p + pos, keylen, p + pos + keylen, datalen, (unsigned int)expire.x);
+    }
+    pos += keylen + datalen;
+    nb++;
+  }
+  alloc_free(buf.s); buf.s = 0;
+  return nb;
+
+ DIE:
+  alloc_free(buf.s); buf.s = 0;
+  if (errno == error_noent) return 0;
+  return -1;
+}
+#endif
diff -U4 -r -N djbdns-1.05/cache.h djbdns-1.05-p13/cache.h
--- djbdns-1.05/cache.h	Sun Feb 11 23:11:45 2001
+++ djbdns-1.05-p13/cache.h	Wed Oct  3 21:16:44 2001
@@ -7,6 +7,10 @@
 extern uint64 cache_motion;
 extern int cache_init(unsigned int);
 extern void cache_set(const char *,unsigned int,const char *,unsigned int,uint32);
 extern char *cache_get(const char *,unsigned int,unsigned int *,uint32 *);
+#ifdef DUMPCACHE
+extern int cache_dump(void);
+extern int cache_slurp(const char *);
+#endif
 
 #endif
diff -U4 -r -N djbdns-1.05/chkshsgr.c djbdns-1.05-p13/chkshsgr.c
--- djbdns-1.05/chkshsgr.c	Sun Feb 11 23:11:45 2001
+++ djbdns-1.05-p13/chkshsgr.c	Wed Oct  3 22:40:52 2001
@@ -1,5 +1,7 @@
 #include "exit.h"
+#include <grp.h>
+#include <unistd.h>
 
 int main()
 {
   short x[4];
diff -U4 -r -N djbdns-1.05/conf-cc djbdns-1.05-p13/conf-cc
--- djbdns-1.05/conf-cc	Sun Feb 11 23:11:45 2001
+++ djbdns-1.05-p13/conf-cc	Wed Oct  3 21:16:44 2001
@@ -1,3 +1,3 @@
-gcc -O2 -Wimplicit -Wunused -Wcomment -Wchar-subscripts -Wuninitialized -Wshadow -Wcast-qual -Wcast-align -Wwrite-strings
+gcc -O2 -Wimplicit -Wunused -Wcomment -Wchar-subscripts -Wuninitialized -Wshadow -Wcast-qual -Wcast-align -Wwrite-strings -DDUMPCACHE
 
 This will be used to compile .c files.
diff -U4 -r -N djbdns-1.05/dns.h djbdns-1.05-p13/dns.h
--- djbdns-1.05/dns.h	Sun Feb 11 23:11:45 2001
+++ djbdns-1.05-p13/dns.h	Sat Oct  6 20:23:55 2001
@@ -19,8 +19,9 @@
 #define DNS_T_RP "\0\21"
 #define DNS_T_SIG "\0\30"
 #define DNS_T_KEY "\0\31"
 #define DNS_T_AAAA "\0\34"
+#define DNS_T_SRV "\0\41"
 #define DNS_T_AXFR "\0\374"
 #define DNS_T_ANY "\0\377"
 
 struct dns_transmit {
@@ -42,8 +43,9 @@
 extern void dns_random_init(const char *);
 extern unsigned int dns_random(unsigned int);
 
 extern void dns_sortip(char *,unsigned int);
+extern void dns_rotateip(char *,unsigned int);
 
 extern void dns_domain_free(char **);
 extern int dns_domain_copy(char **,const char *);
 extern unsigned int dns_domain_length(const char *);
diff -U4 -r -N djbdns-1.05/dns_rotateip.c djbdns-1.05-p13/dns_rotateip.c
--- djbdns-1.05/dns_rotateip.c	Thu Jan  1 02:00:00 1970
+++ djbdns-1.05-p13/dns_rotateip.c	Sat Oct  6 20:23:55 2001
@@ -0,0 +1,15 @@
+#include "byte.h"
+
+void dns_rotateip(char *s, unsigned int n)
+{
+  unsigned int i;
+  char tmp[4];
+
+  i = n >> 2;
+  while (i > 1) {
+    --i;
+    byte_copy(tmp,4,s + (i << 2));
+    byte_copy(s + (i << 2),4,s);
+    byte_copy(s,4,tmp);
+  }
+}
diff -U4 -r -N djbdns-1.05/dnscache-conf.c djbdns-1.05-p13/dnscache-conf.c
--- djbdns-1.05/dnscache-conf.c	Sun Feb 11 23:11:45 2001
+++ djbdns-1.05-p13/dnscache-conf.c	Wed Oct  3 21:16:44 2001
@@ -31,8 +31,12 @@
 char *dir;
 char *user;
 char *loguser;
 struct passwd *pw;
+#ifdef DUMPCACHE
+int useruid;
+int usergid;
+#endif
 const char *myip;
 
 uint32 seed[32];
 int seedpos = 0;
@@ -80,8 +84,16 @@
   if (dir[0] != '/') usage();
   myip = argv[4];
   if (!myip) myip = "127.0.0.1";
 
+#ifdef DUMPCACHE
+  pw = getpwnam(user);
+  seed_addtime();
+  if (!pw)
+    strerr_die3x(111,FATAL,"unknown account ",user);
+  useruid = pw->pw_uid;
+  usergid = pw->pw_gid;
+#endif
   pw = getpwnam(loguser);
   seed_addtime();
   if (!pw)
     strerr_die3x(111,FATAL,"unknown account ",loguser);
@@ -119,8 +131,16 @@
   seed_addtime(); start("env/CACHESIZE"); outs("1000000\n"); finish();
   seed_addtime(); perm(0644);
   seed_addtime(); start("env/DATALIMIT"); outs("3000000\n"); finish();
   seed_addtime(); perm(0644);
+#ifdef DUMPCACHE
+  seed_addtime(); start("env/SLURPCACHE"); outs("dump/slurpcache\n"); finish();
+  seed_addtime(); perm(0644);
+  seed_addtime(); start("env/DUMPCACHE"); outs("dump/dumpcache\n"); finish();
+  seed_addtime(); perm(0644);
+  seed_addtime(); start("env/DUMPCACHETMP"); outs("dump/dumpcache.tmp\n"); finish();
+  seed_addtime(); perm(0644);
+#endif
   seed_addtime(); start("run");
   outs("#!/bin/sh\nexec 2>&1\nexec <seed\nexec envdir ./env sh -c '\n  exec envuidgid "); outs(user);
   outs(" softlimit -o250 -d \"$DATALIMIT\" ");
   outs(auto_home); outs("/bin/dnscache\n'\n"); finish();
@@ -130,8 +150,13 @@
   outs(" multilog t ./main\n"); finish();
   seed_addtime(); perm(0755);
   seed_addtime(); makedir("root");
   seed_addtime(); perm(02755);
+#ifdef DUMPCACHE
+  seed_addtime(); makedir("root/dump");
+  seed_addtime(); owner(useruid,usergid);
+  seed_addtime(); perm(02755);
+#endif
   seed_addtime(); makedir("root/ip");
   seed_addtime(); perm(02755);
   seed_addtime(); start("root/ip/127.0.0.1"); finish();
   seed_addtime(); perm(0600);
diff -U4 -r -N djbdns-1.05/dnscache.c djbdns-1.05-p13/dnscache.c
--- djbdns-1.05/dnscache.c	Sun Feb 11 23:11:45 2001
+++ djbdns-1.05-p13/dnscache.c	Sat Oct  6 17:11:20 2001
@@ -4,8 +4,9 @@
 #include "scan.h"
 #include "strerr.h"
 #include "error.h"
 #include "ip4.h"
+#include "str.h"
 #include "uint16.h"
 #include "uint64.h"
 #include "socket.h"
 #include "dns.h"
@@ -21,8 +22,9 @@
 #include "ndelay.h"
 #include "log.h"
 #include "okclient.h"
 #include "droproot.h"
+#include "sig.h"
 
 static int packetquery(char *buf,unsigned int len,char **q,char qtype[2],char qclass[2],char id[2])
 {
   unsigned int pos;
@@ -46,21 +48,30 @@
 }
 
 
 static char myipoutgoing[4];
-static char myipincoming[4];
 static char buf[1024];
 uint64 numqueries = 0;
 
+struct interf {
+  char ip[4];
+  int udp53;
+  int tcp53;
+  iopause_fd *udp53io;
+  iopause_fd *tcp53io;
+  
+  struct interf *next;
+} ;
 
-static int udp53;
+struct interf *interhead = 0;
 
 #define MAXUDP 200
 static struct udpclient {
   struct query q;
   struct taia start;
   uint64 active; /* query number, if active; otherwise 0 */
   iopause_fd *io;
+  int fd;
   char ip[4];
   uint16 port;
   char id[2];
 } u[MAXUDP];
@@ -77,14 +88,14 @@
 {
   if (!u[j].active) return;
   response_id(u[j].id);
   if (response_len > 512) response_tc();
-  socket_send4(udp53,response,response_len,u[j].ip,u[j].port);
+  socket_send4(u[j].fd,response,response_len,u[j].ip,u[j].port);
   log_querydone(&u[j].active,response_len);
   u[j].active = 0; --uactive;
 }
 
-void u_new(void)
+void u_new(int fd)
 {
   int j;
   int i;
   struct udpclient *x;
@@ -107,10 +118,11 @@
   }
 
   x = u + j;
   taia_now(&x->start);
+  x->fd = fd;
 
-  len = socket_recv4(udp53,buf,sizeof buf,x->ip,&x->port);
+  len = socket_recv4(x->fd,buf,sizeof buf,x->ip,&x->port);
   if (len == -1) return;
   if (len >= sizeof buf) return;
   if (x->port < 1024) if (x->port != 53) return;
   if (!okclient(x->ip)) return;
@@ -128,17 +140,16 @@
   }
 }
 
 
-static int tcp53;
-
 #define MAXTCP 20
 struct tcpclient {
   struct query q;
   struct taia start;
   struct taia timeout;
   uint64 active; /* query number or 1, if active; otherwise 0 */
   iopause_fd *io;
+  int fd;
   char ip[4]; /* send response to this address */
   uint16 port; /* send response to this port */
   char id[2];
   int tcp; /* open TCP socket, if active */
@@ -265,9 +276,9 @@
   t_free(j);
   x->state = 0;
 }
 
-void t_new(void)
+void t_new(int fd)
 {
   int i;
   int j;
   struct tcpclient *x;
@@ -289,10 +300,11 @@
   }
 
   x = t + j;
   taia_now(&x->start);
+  x->fd = fd;
 
-  x->tcp = socket_accept4(tcp53,x->ip,&x->port);
+  x->tcp = socket_accept4(x->fd,x->ip,&x->port);
   if (x->tcp == -1) return;
   if (x->port < 1024) if (x->port != 53) { close(x->tcp); return; }
   if (!okclient(x->ip)) { close(x->tcp); return; }
   if (ndelay_on(x->tcp) == -1) { close(x->tcp); return; } /* Linux bug */
@@ -303,35 +315,62 @@
 
   log_tcpopen(x->ip,x->port);
 }
 
+#ifdef DUMPCACHE
+static void do_dump(void)
+{
+  int r;
+  r = cache_dump();
+  if (r < 0)
+    r = errno;
+  log_dump(r);
+}
+#endif
+
+#define FATAL "dnscache: fatal: "
+
+iopause_fd *io = 0;
+int numio;
+
+void hup_me()
+{
+  if (!roots_init())
+    strerr_die2sys(111,FATAL,"unable to read servers: ");
+
+  log_reread();
+}
 
-iopause_fd io[3 + MAXUDP + MAXTCP];
-iopause_fd *udp53io;
-iopause_fd *tcp53io;
 
 static void doit(void)
 {
   int j;
   struct taia deadline;
   struct taia stamp;
+  struct interf *inter;
   int iolen;
   int r;
 
+  io = (iopause_fd *) alloc((numio + 1 + MAXUDP + MAXTCP) * sizeof(iopause_fd));
+  if (!io)
+    strerr_die2sys(111,FATAL,"unable to alloc io: ");
+
   for (;;) {
     taia_now(&stamp);
     taia_uint(&deadline,120);
     taia_add(&deadline,&deadline,&stamp);
 
     iolen = 0;
 
-    udp53io = io + iolen++;
-    udp53io->fd = udp53;
-    udp53io->events = IOPAUSE_READ;
-
-    tcp53io = io + iolen++;
-    tcp53io->fd = tcp53;
-    tcp53io->events = IOPAUSE_READ;
+    for (inter = interhead; inter != 0; inter = inter->next) {
+      inter->udp53io = io + iolen++;
+      inter->udp53io->fd = inter->udp53;
+      inter->udp53io->events = IOPAUSE_READ;
+
+      inter->tcp53io = io + iolen++;
+      inter->tcp53io->fd = inter->tcp53;
+      inter->tcp53io->events = IOPAUSE_READ;
+    }
 
     for (j = 0;j < MAXUDP;++j)
       if (u[j].active) {
 	u[j].io = io + iolen++;
@@ -371,48 +410,85 @@
 	  if (t[j].io->revents || taia_less(&t[j].timeout,&stamp))
 	    t_rw(j);
       }
 
-    if (udp53io)
-      if (udp53io->revents)
-	u_new();
-
-    if (tcp53io)
-      if (tcp53io->revents)
-	t_new();
+    for (inter = interhead; inter != 0; inter = inter->next) {
+      if (inter->udp53io)
+        if (inter->udp53io->revents)
+	  u_new(inter->udp53);
+
+      if (inter->tcp53io)
+        if (inter->tcp53io->revents)
+	  t_new(inter->tcp53);
+    }
   }
 }
   
-#define FATAL "dnscache: fatal: "
-
 char seed[128];
 
 int main()
 {
   char *x;
+  char nxdip[4];
+  int len;
+  int pos;
+  int oldpos;
+  char iptmp[4];
+  char iperr[IP4_FMT];
+  struct interf *inter;
+  struct interf *itmp;
   unsigned long cachesize;
 
   x = env_get("IP");
   if (!x)
     strerr_die2x(111,FATAL,"$IP not set");
-  if (!ip4_scan(x,myipincoming))
-    strerr_die3x(111,FATAL,"unable to parse IP address ",x);
 
-  udp53 = socket_udp();
-  if (udp53 == -1)
-    strerr_die2sys(111,FATAL,"unable to create UDP socket: ");
-  if (socket_bind4_reuse(udp53,myipincoming,53) == -1)
-    strerr_die2sys(111,FATAL,"unable to bind UDP socket: ");
-
-  tcp53 = socket_tcp();
-  if (tcp53 == -1)
-    strerr_die2sys(111,FATAL,"unable to create TCP socket: ");
-  if (socket_bind4_reuse(tcp53,myipincoming,53) == -1)
-    strerr_die2sys(111,FATAL,"unable to bind TCP socket: ");
+  len = str_len(x);
+  numio = pos = oldpos = 0;
+  
+  while (pos < len) {
+    if (pos) oldpos = pos + 1;
+    pos = oldpos + str_chr(x + oldpos,'/');
+    x[pos] = 0;
+    if (!str_len(x + oldpos)) continue;
+    
+    if (!ip4_scan(x + oldpos,iptmp))
+      strerr_die3x(111,FATAL,"unable to parse IP address ",x + oldpos);
+      
+    inter = (struct interf *) alloc(sizeof(struct interf));
+    
+    if (interhead == 0) interhead = inter;
+    else if (interhead->next == 0) interhead->next = inter;
+    else {
+      for (itmp = interhead; itmp->next != 0; itmp = itmp->next);
+      itmp->next = inter;
+    }
+    
+    inter->next = 0;
+    
+    inter->udp53 = socket_udp();
+    if (inter->udp53 == -1)
+      strerr_die4sys(111,FATAL,"unable to create UDP socket for IP address ",x + oldpos,": ");
+    if (socket_bind4_reuse(inter->udp53,iptmp,53) == -1)
+      strerr_die4sys(111,FATAL,"unable to bind UDP socket for IP address ",x + oldpos,": ");
+      
+    inter->tcp53 = socket_tcp();
+    if (inter->tcp53 == -1)
+      strerr_die4sys(111,FATAL,"unable to create TCP socket for IP address ",x + oldpos,": ");
+    if (socket_bind4_reuse(inter->tcp53,iptmp,53) == -1)
+      strerr_die4sys(111,FATAL,"unable to bind TCP socket for IP address ",x + oldpos,": ");
+      
+    numio++;
+    log_listen(iptmp);
+  }
+
+  if (interhead == 0)
+    strerr_die2x(111,FATAL,"no interfaces to listen on");
 
   droproot(FATAL);
 
-  socket_tryreservein(udp53,131072);
+  for (inter = interhead; inter != 0; inter = inter->next)
+    socket_tryreservein(inter->udp53,131072);
 
   byte_zero(seed,sizeof seed);
   read(0,seed,sizeof seed);
   dns_random_init(seed);
@@ -429,19 +505,44 @@
     strerr_die2x(111,FATAL,"$CACHESIZE not set");
   scan_ulong(x,&cachesize);
   if (!cache_init(cachesize))
     strerr_die3x(111,FATAL,"not enough memory for cache of size ",x);
+#ifdef DUMPCACHE
+  x = env_get("SLURPCACHE");
+  if (x) {
+    int nb = cache_slurp(x);
+    if (nb < 0)
+      strerr_die4sys(111,FATAL,"unable to slurp cache ",x," : ");
+    else
+      log_slurp(nb);
+  }
+#endif
 
   if (env_get("HIDETTL"))
     response_hidettl();
   if (env_get("FORWARDONLY"))
     query_forwardonly();
 
+  x = env_get("NXDSPECIAL");
+  if (x) {
+    if (!ip4_scan(x,nxdip))
+      strerr_die3x(111,FATAL,"unable to parse NXDSPECIAL IP address ",x);
+    query_nxdspecial(nxdip);
+  }
+
   if (!roots_init())
     strerr_die2sys(111,FATAL,"unable to read servers: ");
 
-  if (socket_listen(tcp53,20) == -1)
-    strerr_die2sys(111,FATAL,"unable to listen on TCP socket: ");
+  for (inter = interhead; inter != 0; inter = inter->next)
+    if (socket_listen(inter->tcp53,20) == -1) {
+      iperr[ip4_fmt(iperr,inter->ip)] = 0;
+      strerr_die4sys(111,FATAL,"unable to listen on TCP socket for IP ",iperr,": ");
+    }
+
+#ifdef DUMPCACHE
+  sig_catch(sig_alarm,do_dump);
+#endif
+  sig_catch(sig_hangup, hup_me);
 
   log_startup();
   doit();
 }
diff -U4 -r -N djbdns-1.05/dnsfilter.c djbdns-1.05-p13/dnsfilter.c
--- djbdns-1.05/dnsfilter.c	Sun Feb 11 23:11:45 2001
+++ djbdns-1.05-p13/dnsfilter.c	Wed Oct  3 23:20:20 2001
@@ -40,8 +40,9 @@
 int inbuflen = 0;
 iopause_fd *inio;
 int flag0 = 1;
 
+int opt_replace = 0;
 iopause_fd *io;
 int iolen;
 
 char servers[64];
@@ -50,14 +51,18 @@
 
 void errout(int i)
 {
   int j;
-
-  if (!stralloc_copys(&x[i].middle,":")) nomem();
-  if (!stralloc_cats(&x[i].middle,error_str(errno))) nomem();
-  for (j = 0;j < x[i].middle.len;++j)
-    if (x[i].middle.s[j] == ' ')
-      x[i].middle.s[j] = '-';
+ 
+  if (opt_replace) 
+    x[i].middle.len=0;
+  else {
+    if (!stralloc_copys(&x[i].middle,":")) nomem();
+    if (!stralloc_cats(&x[i].middle,error_str(errno))) nomem();
+    for (j = 0;j < x[i].middle.len;++j)
+      if (x[i].middle.s[j] == ' ')
+        x[i].middle.s[j] = '-';
+  }
 }
 
 int main(int argc,char **argv)
 {
@@ -68,9 +73,9 @@
   int i;
   int j;
   int r;
 
-  while ((opt = getopt(argc,argv,"c:l:")) != opteof)
+  while ((opt = getopt(argc,argv,"c:l:r")) != opteof)
     switch(opt) {
       case 'c':
 	scan_ulong(optarg,&u);
 	if (u < 1) u = 1;
@@ -82,10 +87,13 @@
 	if (u < 1) u = 1;
 	if (u > 1000000) u = 1000000;
 	xmax = u;
 	break;
+      case 'r':
+	opt_replace = 1;	  
+	break;
       default:
-	strerr_die1x(111,"dnsfilter: usage: dnsfilter [ -c concurrency ] [ -l lines ]");
+	strerr_die1x(111,"dnsfilter: usage: dnsfilter [ -c concurrency ] [ -l lines ] [-r]");
     }
 
   x = (struct line *) alloc(xmax * sizeof(struct line));
   if (!x) nomem();
@@ -139,10 +147,15 @@
 	}
 	else if (r == 1) {
 	  if (dns_name_packet(&x[i].middle,x[i].dt.packet,x[i].dt.packetlen) == -1)
 	    errout(i);
-	  if (x[i].middle.len)
-	    if (!stralloc_cats(&x[i].left,"=")) nomem();
+	  if (x[i].middle.len) {
+	    if (opt_replace) {
+	      if (!stralloc_copys(&x[i].left, "")) nomem();
+	    } else {
+	      if (!stralloc_cats(&x[i].left, "=")) nomem();
+	    }
+	  }
 	  x[i].flagactive = 0;
 	  --numactive;
 	}
       }
diff -U4 -r -N djbdns-1.05/hassgact.h1 djbdns-1.05-p13/hassgact.h1
--- djbdns-1.05/hassgact.h1	Thu Jan  1 02:00:00 1970
+++ djbdns-1.05-p13/hassgact.h1	Wed Oct  3 21:16:44 2001
@@ -0,0 +1 @@
+/* sysdep: -sigaction */
diff -U4 -r -N djbdns-1.05/hassgact.h2 djbdns-1.05-p13/hassgact.h2
--- djbdns-1.05/hassgact.h2	Thu Jan  1 02:00:00 1970
+++ djbdns-1.05-p13/hassgact.h2	Wed Oct  3 21:16:44 2001
@@ -0,0 +1,2 @@
+/* sysdep: +sigaction */
+#define HASSIGACTION 1
diff -U4 -r -N djbdns-1.05/hassgprm.h1 djbdns-1.05-p13/hassgprm.h1
--- djbdns-1.05/hassgprm.h1	Thu Jan  1 02:00:00 1970
+++ djbdns-1.05-p13/hassgprm.h1	Wed Oct  3 21:16:44 2001
@@ -0,0 +1 @@
+/* sysdep: -sigprocmask */
diff -U4 -r -N djbdns-1.05/hassgprm.h2 djbdns-1.05-p13/hassgprm.h2
--- djbdns-1.05/hassgprm.h2	Thu Jan  1 02:00:00 1970
+++ djbdns-1.05-p13/hassgprm.h2	Wed Oct  3 21:16:44 2001
@@ -0,0 +1,2 @@
+/* sysdep: +sigprocmask */
+#define HASSIGPROCMASK 1
diff -U4 -r -N djbdns-1.05/log.c djbdns-1.05-p13/log.c
--- djbdns-1.05/log.c	Sun Feb 11 23:11:45 2001
+++ djbdns-1.05-p13/log.c	Fri Oct  5 15:39:38 2001
@@ -87,13 +87,40 @@
     string(".");
   }
 }
 
+void log_reread(void)
+{
+  string("rereading servers configuration");
+  line();
+}
+
 void log_startup(void)
 {
   string("starting");
   line();
 }
+
+void log_listen(const char addr[4])
+{
+  string("listening on ");
+  ip(addr);
+  line();
+}
+
+#ifdef DUMPCACHE
+void log_slurp(int nb)
+{
+  string("slurp "); number(nb);
+  line();
+}
+
+void log_dump(int err)
+{
+  string("dump err "); number(err);
+  line();
+}
+#endif
 
 void log_query(uint64 *qnum,const char client[4],unsigned int port,const char id[2],const char *q,const char qtype[2])
 {
   string("query "); number(*qnum); space();
diff -U4 -r -N djbdns-1.05/log.h djbdns-1.05-p13/log.h
--- djbdns-1.05/log.h	Sun Feb 11 23:11:45 2001
+++ djbdns-1.05-p13/log.h	Fri Oct  5 15:44:08 2001
@@ -3,8 +3,14 @@
 
 #include "uint64.h"
 
 extern void log_startup(void);
+extern void log_listen(const char *);
+#ifdef DUMPCACHE
+extern void log_slurp(int);
+extern void log_dump(int);
+#endif
+extern void log_reread(void);
 
 extern void log_query(uint64 *,const char *,unsigned int,const char *,const char *,const char *);
 extern void log_querydrop(uint64 *);
 extern void log_querydone(uint64 *,unsigned int);
diff -U4 -r -N djbdns-1.05/okclient.c djbdns-1.05-p13/okclient.c
--- djbdns-1.05/okclient.c	Sun Feb 11 23:11:45 2001
+++ djbdns-1.05-p13/okclient.c	Wed Oct  3 02:20:12 2001
@@ -1,6 +1,7 @@
 #include <sys/types.h>
 #include <sys/stat.h>
+#include "env.h"
 #include "str.h"
 #include "ip4.h"
 #include "okclient.h"
 
@@ -9,8 +10,16 @@
 int okclient(char ip[4])
 {
   struct stat st;
   int i;
+  static int init_done=0;
+  if (!init_done) {
+    if (env_get("OKCLIENT")) {
+      init_done=1;
+    } else
+      init_done=2;
+  }
+  if (init_done==1) return 1;
 
   fn[0] = 'i';
   fn[1] = 'p';
   fn[2] = '/';
diff -U4 -r -N djbdns-1.05/prot.c djbdns-1.05-p13/prot.c
--- djbdns-1.05/prot.c	Sun Feb 11 23:11:45 2001
+++ djbdns-1.05-p13/prot.c	Wed Oct  3 22:49:25 2001
@@ -1,6 +1,8 @@
 #include "hasshsgr.h"
 #include "prot.h"
+#include <grp.h>
+#include <unistd.h>
 
 int prot_gid(int gid)
 {
 #ifdef HASSHORTSETGROUPS
diff -U4 -r -N djbdns-1.05/query.c djbdns-1.05-p13/query.c
--- djbdns-1.05/query.c	Sun Feb 11 23:11:45 2001
+++ djbdns-1.05-p13/query.c	Sat Oct  6 17:10:34 2001
@@ -19,8 +19,17 @@
 {
   flagforwardonly = 1;
 }
 
+static int flagnxdspecial = 0;
+static char nxdip[4];
+
+void query_nxdspecial(const char ip[4])
+{
+  byte_copy(nxdip,4,ip);
+  flagnxdspecial = 1;
+}
+
 static void cachegeneric(const char type[2],const char *d,const char *data,unsigned int datalen,uint32 ttl)
 {
   unsigned int len;
   char key[257];
@@ -245,8 +254,9 @@
     byte_copy(key + 2,dlen,d);
     case_lowerb(key + 2,dlen);
     cached = cache_get(key,dlen + 2,&cachedlen,&ttl);
     if (cached) {
+      soattl = rcode = 0;
       log_cachednxdomain(d);
       goto NXDOMAIN;
     }
 
@@ -694,9 +704,14 @@
 
     NXDOMAIN:
     if (z->level) goto LOWERLEVEL;
     if (!rqa(z)) goto DIE;
-    response_nxdomain();
+    if (flagnxdspecial && typematch(DNS_T_A,dtype)) {
+      if (!response_rstart(d,DNS_T_A,rcode == 3 ? soattl : ttl)) goto DIE;
+      if (!response_addbytes(nxdip,4)) goto DIE;
+      response_rfinish(RESPONSE_ANSWER);
+    } else
+      response_nxdomain();
     cleanup(z);
     return 1;
   }
 
diff -U4 -r -N djbdns-1.05/query.h djbdns-1.05-p13/query.h
--- djbdns-1.05/query.h	Sun Feb 11 23:11:45 2001
+++ djbdns-1.05-p13/query.h	Sat Oct  6 17:10:48 2001
@@ -27,6 +27,7 @@
 extern void query_io(struct query *,iopause_fd *,struct taia *);
 extern int query_get(struct query *,iopause_fd *,struct taia *);
 
 extern void query_forwardonly(void);
+extern void query_nxdspecial(const char *);
 
 #endif
diff -U4 -r -N djbdns-1.05/seek_set.c djbdns-1.05-p13/seek_set.c
--- djbdns-1.05/seek_set.c	Sun Feb 11 23:11:45 2001
+++ djbdns-1.05-p13/seek_set.c	Wed Oct  3 22:15:22 2001
@@ -1,5 +1,6 @@
 #include <sys/types.h>
+#include <unistd.h>
 #include "seek.h"
 
 #define SET 0 /* sigh */
 
diff -U4 -r -N djbdns-1.05/server.c djbdns-1.05-p13/server.c
--- djbdns-1.05/server.c	Sun Feb 11 23:11:45 2001
+++ djbdns-1.05-p13/server.c	Sat Oct  6 20:03:22 2001
@@ -10,8 +10,10 @@
 #include "droproot.h"
 #include "qlog.h"
 #include "response.h"
 #include "dns.h"
+#include "alloc.h"
+#include "iopause.h"
 
 extern char *fatal;
 extern char *starting;
 extern int respond(char *,char *,char *);
@@ -24,8 +26,46 @@
 static int len;
 
 static char *q;
 
+
+static void hex(unsigned char c)
+{
+  buffer_put(buffer_2,"0123456789abcdef" + (c >> 4),1);
+  buffer_put(buffer_2,"0123456789abcdef" + (c & 15),1);
+}
+
+static void put_ip(const char i[4])
+{
+  hex(i[0]);
+  hex(i[1]);
+  hex(i[2]);
+  hex(i[3]);
+}
+
+static void string(const char *s)
+{
+  buffer_puts(buffer_2,s);
+}
+
+static void line(void)
+{
+  string("\n");
+  buffer_flush(buffer_2);
+}
+
+void log_listen(const char addr[4])
+{
+  string("listening on ");
+  put_ip(addr);
+  line();
+}
+
+void nomem()
+{
+  strerr_die2x(111,fatal,"out of memory");
+}
+
 static int doit(void)
 {
   unsigned int pos;
   char header[12];
@@ -50,17 +90,29 @@
     if (byte_diff(qclass,2,DNS_C_ANY)) goto WEIRDCLASS;
   response[3] &= ~128;
   if (!(header[2] & 1)) response[2] &= ~1;
 
+  if ((header[2] & 126) == 0x24) /* NOTIFY + AA */
+    if (byte_equal(qtype,2,DNS_T_SOA)) {
+      response[2] |= 0x20; /* NOTIFY */
+      qlog(ip,port,header,q,qtype," N ");
+      return 1;
+    }
+
   if (header[2] & 126) goto NOTIMP;
   if (byte_equal(qtype,2,DNS_T_AXFR)) goto NOTIMP;
 
   case_lowerb(q,dns_domain_length(q));
   if (!respond(q,qtype,ip)) {
     qlog(ip,port,header,q,qtype," - ");
     return 0;
   }
-  qlog(ip,port,header,q,qtype," + ");
+
+  if ((response[2] & 4) && (response[3] & 3))
+    qlog(ip,port,header,q,qtype," X ");
+  else
+    qlog(ip,port,header,q,qtype," + ");
+
   return 1;
 
   NOTIMP:
   response[3] &= ~15;
@@ -81,36 +133,76 @@
 
 int main()
 {
   char *x;
-  int udp53;
+  int *udp53;
+  unsigned int off;
+  unsigned int cnt;
+  iopause_fd *iop;
 
   x = env_get("IP");
   if (!x)
     strerr_die2x(111,fatal,"$IP not set");
-  if (!ip4_scan(x,ip))
-    strerr_die3x(111,fatal,"unable to parse IP address ",x);
-
-  udp53 = socket_udp();
-  if (udp53 == -1)
-    strerr_die2sys(111,fatal,"unable to create UDP socket: ");
-  if (socket_bind4_reuse(udp53,ip,53) == -1)
-    strerr_die2sys(111,fatal,"unable to bind UDP socket: ");
+  off=0;
+  cnt=0;
+  while (x[off]) {
+    unsigned int l;
+    char dummy[4];
+    l=ip4_scan(x+off,dummy);
+	if (!l)
+      strerr_die3x(111,fatal,"unable to parse IP address ",x+off);
+	cnt++;
+	if (!x[off+l]) break;
+	if (x[off+l]!='/')
+      strerr_die3x(111,fatal,"unable to parse IP address ",x+off);
+	off+=l+1;
+  }
+  udp53=(int *) alloc(sizeof(int) *cnt);
+  if (!udp53) nomem();
+  iop=(iopause_fd *) alloc(sizeof(*iop) * cnt);
+  if (!iop) nomem();
+
+  off=0;
+  cnt=0;
+  while (x[off]) {
+    unsigned int l;
+    l=ip4_scan(x+off,ip);
+    udp53[cnt] = socket_udp();
+    if (udp53[cnt] == -1)
+      strerr_die2sys(111,fatal,"unable to create UDP socket: ");
+    if (socket_bind4_reuse(udp53[cnt],ip,53) == -1)
+      strerr_die2sys(111,fatal,"unable to bind UDP socket: ");
+    ndelay_off(udp53[cnt]);
+    socket_tryreservein(udp53[cnt],65536);
+    iop[cnt].fd=udp53[cnt];
+    iop[cnt].events=IOPAUSE_READ;
+    log_listen(ip);
+    cnt++;
+    if (!x[off+l]) break;
+    off+=l+1;
+  }
 
   droproot(fatal);
 
   initialize();
-  
-  ndelay_off(udp53);
-  socket_tryreservein(udp53,65536);
 
   buffer_putsflush(buffer_2,starting);
-
+  
   for (;;) {
-    len = socket_recv4(udp53,buf,sizeof buf,ip,&port);
-    if (len < 0) continue;
-    if (!doit()) continue;
-    if (response_len > 512) response_tc();
-    socket_send4(udp53,response,response_len,ip,port);
-    /* may block for buffer space; if it fails, too bad */
+    struct taia stamp;
+    struct taia deadline;
+	unsigned int i;
+    taia_now(&stamp);
+    taia_uint(&deadline,300);
+    taia_add(&deadline,&deadline,&stamp);
+    iopause(iop,cnt,&deadline,&stamp);
+	for (i=0;i<cnt;i++)
+	  if (iop[i].revents) {
+        len = socket_recv4(udp53[i],buf,sizeof buf,ip,&port);
+        if (len < 0) continue;
+        if (!doit()) continue;
+        if (response_len > 512) response_tc();
+        socket_send4(udp53[i],response,response_len,ip,port);
+        /* may block for buffer space; if it fails, too bad */
+	  }
   }
 }
diff -U4 -r -N djbdns-1.05/sig.c djbdns-1.05-p13/sig.c
--- djbdns-1.05/sig.c	Thu Jan  1 02:00:00 1970
+++ djbdns-1.05-p13/sig.c	Wed Oct  3 21:16:44 2001
@@ -0,0 +1,12 @@
+#include <signal.h>
+#include "sig.h"
+
+int sig_alarm = SIGALRM;
+int sig_child = SIGCHLD;
+int sig_cont = SIGCONT;
+int sig_hangup = SIGHUP;
+int sig_pipe = SIGPIPE;
+int sig_term = SIGTERM;
+
+void (*sig_defaulthandler)() = SIG_DFL;
+void (*sig_ignorehandler)() = SIG_IGN;
diff -U4 -r -N djbdns-1.05/sig.h djbdns-1.05-p13/sig.h
--- djbdns-1.05/sig.h	Thu Jan  1 02:00:00 1970
+++ djbdns-1.05-p13/sig.h	Wed Oct  3 21:16:44 2001
@@ -0,0 +1,25 @@
+#ifndef SIG_H
+#define SIG_H
+
+extern int sig_alarm;
+extern int sig_child;
+extern int sig_cont;
+extern int sig_hangup;
+extern int sig_pipe;
+extern int sig_term;
+
+extern void (*sig_defaulthandler)();
+extern void (*sig_ignorehandler)();
+
+extern void sig_catch(int,void (*)());
+#define sig_ignore(s) (sig_catch((s),sig_ignorehandler))
+#define sig_uncatch(s) (sig_catch((s),sig_defaulthandler))
+
+extern void sig_block(int);
+extern void sig_unblock(int);
+extern void sig_blocknone(void);
+extern void sig_pause(void);
+
+extern void sig_dfl(int);
+
+#endif
diff -U4 -r -N djbdns-1.05/sig_block.c djbdns-1.05-p13/sig_block.c
--- djbdns-1.05/sig_block.c	Thu Jan  1 02:00:00 1970
+++ djbdns-1.05-p13/sig_block.c	Wed Oct  3 21:16:44 2001
@@ -0,0 +1,38 @@
+#include <signal.h>
+#include "sig.h"
+#include "hassgprm.h"
+
+void sig_block(int sig)
+{
+#ifdef HASSIGPROCMASK
+  sigset_t ss;
+  sigemptyset(&ss);
+  sigaddset(&ss,sig);
+  sigprocmask(SIG_BLOCK,&ss,(sigset_t *) 0);
+#else
+  sigblock(1 << (sig - 1));
+#endif
+}
+
+void sig_unblock(int sig)
+{
+#ifdef HASSIGPROCMASK
+  sigset_t ss;
+  sigemptyset(&ss);
+  sigaddset(&ss,sig);
+  sigprocmask(SIG_UNBLOCK,&ss,(sigset_t *) 0);
+#else
+  sigsetmask(sigsetmask(~0) & ~(1 << (sig - 1)));
+#endif
+}
+
+void sig_blocknone(void)
+{
+#ifdef HASSIGPROCMASK
+  sigset_t ss;
+  sigemptyset(&ss);
+  sigprocmask(SIG_SETMASK,&ss,(sigset_t *) 0);
+#else
+  sigsetmask(0);
+#endif
+}
diff -U4 -r -N djbdns-1.05/sig_catch.c djbdns-1.05-p13/sig_catch.c
--- djbdns-1.05/sig_catch.c	Thu Jan  1 02:00:00 1970
+++ djbdns-1.05-p13/sig_catch.c	Wed Oct  3 21:16:44 2001
@@ -0,0 +1,16 @@
+#include <signal.h>
+#include "sig.h"
+#include "hassgact.h"
+
+void sig_catch(int sig,void (*f)())
+{
+#ifdef HASSIGACTION
+  struct sigaction sa;
+  sa.sa_handler = f;
+  sa.sa_flags = 0;
+  sigemptyset(&sa.sa_mask);
+  sigaction(sig,&sa,(struct sigaction *) 0);
+#else
+  signal(sig,f); /* won't work under System V, even nowadays---dorks */
+#endif
+}
diff -U4 -r -N djbdns-1.05/sig_pause.c djbdns-1.05-p13/sig_pause.c
--- djbdns-1.05/sig_pause.c	Thu Jan  1 02:00:00 1970
+++ djbdns-1.05-p13/sig_pause.c	Wed Oct  3 21:16:44 2001
@@ -0,0 +1,14 @@
+#include <signal.h>
+#include "sig.h"
+#include "hassgprm.h"
+
+void sig_pause(void)
+{
+#ifdef HASSIGPROCMASK
+  sigset_t ss;
+  sigemptyset(&ss);
+  sigsuspend(&ss);
+#else
+  sigpause(0);
+#endif
+}
diff -U4 -r -N djbdns-1.05/tinydns-data.c djbdns-1.05-p13/tinydns-data.c
--- djbdns-1.05/tinydns-data.c	Sun Feb 11 23:11:45 2001
+++ djbdns-1.05-p13/tinydns-data.c	Wed Oct  3 02:09:01 2001
@@ -158,20 +158,18 @@
   if (cdb_make_add(&cdb,key.s,key.len,result.s,result.len) == -1)
     die_datatmp();
 }
 
-buffer b;
-char bspace[1024];
-
 static stralloc line;
-int match = 1;
 unsigned long linenum = 0;
 
 #define NUMFIELDS 15
 static stralloc f[NUMFIELDS];
 
 static char *d1;
 static char *d2;
+static char *contact;
+
 char dptr[DNS_NAME4_DOMAIN];
 
 char strnum[FMT_ULONG];
 
@@ -180,9 +178,9 @@
   strnum[fmt_ulong(strnum,linenum)] = 0;
   strerr_die4x(111,FATAL,"unable to parse data line ",strnum,why);
 }
 
-int main()
+int load(const char *fname)
 {
   int fddata;
   int i;
   int j;
@@ -195,22 +193,21 @@
   char ip[4];
   char type[2];
   char soa[20];
   char buf[4];
+  char srv[6];
+  int match;
+  buffer b;
+  char bspace[1024];
 
-  umask(022);
-
-  fddata = open_read("data");
+  fddata = open_read(fname);
   if (fddata == -1)
-    strerr_die2sys(111,FATAL,"unable to open data: ");
+    strerr_die4sys(111,FATAL,"unable to open ",fname,": ");
   defaultsoa_init(fddata);
 
   buffer_init(&b,buffer_unixread,fddata,bspace,sizeof bspace);
 
-  fdcdb = open_trunc("data.tmp");
-  if (fdcdb == -1) die_datatmp();
-  if (cdb_make_start(&cdb,fdcdb) == -1) die_datatmp();
-
+  match = 1;
   while (match) {
     ++linenum;
     if (getln(&b,&line,&match,'\n') == -1)
       strerr_die2sys(111,FATAL,"unable to read line: ");
@@ -246,8 +243,13 @@
         if (cdb_make_add(&cdb,key.s,key.len,loc,2) == -1)
           die_datatmp();
 	break;
 
+      case 'D':
+       if (!dns_domain_fromdot(&contact,f[0].s,f[0].len)) nomem();
+       if (f[0].len == 0) contact = NULL;
+       break;
+
       case 'Z':
 	if (!dns_domain_fromdot(&d1,f[0].s,f[0].len)) nomem();
 
 	if (!stralloc_0(&f[3])) nomem();
@@ -297,10 +299,15 @@
 
 	if (line.s[0] == '.') {
 	  rr_start(DNS_T_SOA,ttl ? TTL_NEGATIVE : 0,ttd,loc);
 	  rr_addname(d2);
-	  rr_add("\12hostmaster",11);
-	  rr_addname(d1);
+          if (!contact) {
+            rr_add("\12hostmaster",11);
+            rr_addname(d1);
+          } else {
+            rr_addname(contact);
+          }
+	  
 	  rr_add(defaultsoa,20);
 	  rr_finish(d1);
 	}
 
@@ -368,8 +375,45 @@
 	  rr_add(ip,4);
 	  rr_finish(d2);
 	}
 	break;
+	
+      case 'S':
+	if (!dns_domain_fromdot(&d1,f[0].s,f[0].len)) nomem();
+	if (!stralloc_0(&f[6])) nomem();
+	if (!scan_ulong(f[6].s,&ttl)) ttl = TTL_POSITIVE;
+	ttdparse(&f[7],ttd);
+	locparse(&f[8],loc);
+
+	if (!stralloc_0(&f[1])) nomem();
+
+	if (byte_chr(f[2].s,f[2].len,'.') >= f[2].len) {
+	  if (!stralloc_cats(&f[2],".srv.")) nomem();
+	  if (!stralloc_catb(&f[2],f[0].s,f[0].len)) nomem();
+	}
+	if (!dns_domain_fromdot(&d2,f[2].s,f[2].len)) nomem();
+
+	if (!stralloc_0(&f[4])) nomem();
+	if (!scan_ulong(f[4].s,&u)) u = 0;
+	uint16_pack_big(srv,u);
+	if (!stralloc_0(&f[5])) nomem();
+	if (!scan_ulong(f[5].s,&u)) u = 0;
+	uint16_pack_big(srv + 2,u);
+	if (!stralloc_0(&f[3])) nomem();
+	if (!scan_ulong(f[3].s,&u)) nomem();
+	uint16_pack_big(srv + 4,u);
+
+	rr_start(DNS_T_SRV,ttl,ttd,loc);
+	rr_add(srv,6);
+	rr_addname(d2);
+	rr_finish(d1);
+
+	if (ip4_scan(f[1].s,ip)) {
+	  rr_start(DNS_T_A,ttl,ttd,loc);
+	  rr_add(ip,4);
+	  rr_finish(d2);
+	}
+	break;
 
       case '^': case 'C':
 	if (!dns_domain_fromdot(&d1,f[0].s,f[0].len)) nomem();
 	if (!dns_domain_fromdot(&d2,f[1].s,f[1].len)) nomem();
@@ -443,8 +487,23 @@
 
       default:
         syntaxerror(": unrecognized leading character");
     }
+  }
+  close(fddata);
+}
+
+int main(int argc, char **argv)
+{
+  umask(022);
+  fdcdb = open_trunc("data.tmp");
+  if (fdcdb == -1) die_datatmp();
+  if (cdb_make_start(&cdb,fdcdb) == -1) die_datatmp();
+
+  if (argc == 1)
+    load("data");
+  while(--argc) {
+    load(argv[argc]);
   }
 
   if (cdb_make_finish(&cdb) == -1) die_datatmp();
   if (fsync(fdcdb) == -1) die_datatmp();
diff -U4 -r -N djbdns-1.05/trysgact.c djbdns-1.05-p13/trysgact.c
--- djbdns-1.05/trysgact.c	Thu Jan  1 02:00:00 1970
+++ djbdns-1.05-p13/trysgact.c	Wed Oct  3 21:16:44 2001
@@ -0,0 +1,10 @@
+#include <signal.h>
+
+main()
+{
+  struct sigaction sa;
+  sa.sa_handler = 0;
+  sa.sa_flags = 0;
+  sigemptyset(&sa.sa_mask);
+  sigaction(0,&sa,(struct sigaction *) 0);
+}
diff -U4 -r -N djbdns-1.05/trysgprm.c djbdns-1.05-p13/trysgprm.c
--- djbdns-1.05/trysgprm.c	Thu Jan  1 02:00:00 1970
+++ djbdns-1.05-p13/trysgprm.c	Wed Oct  3 21:16:44 2001
@@ -0,0 +1,10 @@
+#include <signal.h>
+
+main()
+{
+  sigset_t ss;
+ 
+  sigemptyset(&ss);
+  sigaddset(&ss,SIGCHLD);
+  sigprocmask(SIG_SETMASK,&ss,(sigset_t *) 0);
+}
